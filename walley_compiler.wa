;; walley language compiler
;; by Yiyi Wang
;; all rights reserved


;; def opcodes
(def opcode 
  {:SET 0x0 
   :GET 0x1
   :CONST 0x2
   
   :CONST_INTEGER 0x2100
   :CONST_FLOAT 0x2200
   :CONST_STRING 0x2300
   :CONST_NULL 0x2400
   :CONST_LOAD 0x2500

   :MAKELAMBDA 0x3
   :RETURN 0x4
   :NEWFRAME 0x5
   :PUSH_ARG 0x6
   :CALL 0x7
   :JMP 0x8
   :TEST 0x9
   :SET_TOP 0xA
   :TAIL_CALL_PUSH 0xB
   :OBJECT_GET_SELF 0xC
   :OBJECT_GET_PARENT 0xD
   :TABLE_GET 0xE
   })

;; generate instructions data structions
(def Make-Instructions 
  (fn []
    {:array #[]
     :start-pc 0
     }))

;; insts push instructions
(def Insts-push 
  (fn [insts v]
    (vector:push! insts:array v)))
;; insts set instructions
(def Insts-set!
  (fn [insts offset v]
    (insts:array offset v)))

;; insts to string
(def Insts->string 
  (fn [insts]
    (def insts-array insts:array)
    (def insts-length (vector:length insts-array))
    (def helper 
      (fn [count output]
        (if (= count insts-length)
          output
          (helper (+ count 1)
                  (string-append output 
                                 (int:->string insts-array[count]
                                               "%04x "))))))
    (helper 0 "")))
;; print insts
(def Insts-print 
  (fn [insts]
    (print (Insts->string insts))))

;; test instructions
;(def x (Make-Instructions))
;(Insts-push x 12)
;(Insts-print x)

;; def module
;; module saves variables names and their offsets
;; under global scope
(def Make-Module 
  (fn []
    {}))

;; make variable table frame
(def Make-Variable-Table-Frame  
  (fn []
    {}))
;; push variable name to variable table frame
(def VTF-push 
  (fn [vtf v]
    (vtf v (table:length vtf))))
;; make variable table
;; vector that store the variable table frame
(def Make-Variable-Table
  (fn []
    #[]))
;; initialize a variable table
(def VT-init
  (fn []
    (def vt #[])  ;;; def a variable table
    (def vtf (Make-Variable-Table-Frame))  ;;; def a variable table frame 
    (vector:push! vt vtf) ;;; add this variable table frame to variable table
   
    ;; add predefined variable name
    ;; set frame0                        ;;    module
    (VTF-push vtf :cons)                   ;;  global 0
    (VTF-push vtf :car)                    ;;  global 1
    (VTF-push vtf :cdr)                    ;;  global 2
    (VTF-push vtf :+)                      ;;  global 3
    (VTF-push vtf :-)                      ;;  global 4
    (VTF-push vtf :*)                      ;;  global 5
    (VTF-push vtf :/)                      ;;  global 6
    (VTF-push vtf :Vector!)                ;;  global 7 
    (VTF-push vtf :Vector)                 ;;  global 8
    (VTF-push vtf :vector-length)          ;;  vector 9 
    
    (VTF-push vtf :vector-push!)           ;;  vector 10 
    (VTF-push vtf :vector-pop!)            ;;  vector 11 
    (VTF-push vtf :=)                      ;;  global 12 
    (VTF-push vtf :<)                      ;;  global 13
    (VTF-push vtf :<=)                     ;;  global 14 
    (VTF-push vtf :eq?)                    ;;  global 15
    (VTF-push vtf :eval)                   ;;  global 16 
    (VTF-push vtf :exit)                   ;;  global 17
    (VTF-push vtf :>)                      ;;  global 18
    (VTF-push vtf :>=)                     ;;  global 19
    
    (VTF-push vtf :parse)                  ;;  global 20
    (VTF-push vtf :random)                 ;;  global 21 
    (VTF-push vtf :strcmp)                 ;;  global 22 
    (VTF-push vtf :string-slice)           ;;  string 23 
    (VTF-push vtf :string-length)          ;;  string 24 
    (VTF-push vtf :string-append)          ;;  string 25 
    (VTF-push vtf :Table)                  ;;  global 26 
    (VTF-push vtf :table-keys)             ;;  table 27 
    (VTF-push vtf :table-delete)           ;;  table 28 
    (VTF-push vtf :file-read)              ;;  file 29 
    
    (VTF-push vtf :file-write)             ;;  file 30 
    (VTF-push vtf :sys-argv)               ;;  sys  31
    (VTF-push vtf :int->string)            ;;  int  32 
    (VTF-push vtf :float->string)          ;;  float 33 
    (VTF-push vtf :input)                  ;;  global 34
    (VTF-push vtf :print)                  ;;  global 35 
    (VTF-push vtf :string->int)            ;;  string 36 
    (VTF-push vtf :string->float)          ;;  string 37 
    (VTF-push vtf :ratio?)                 ;;  global 38 
    (VTF-push vtf :ratio-numer)            ;;  ratio 39 
    
    (VTF-push vtf :ratio-denom)            ;;  ratio 40 
    (VTF-push vtf :gensym)                 ;;  global 41 
    (VTF-push vtf :add-proto)              ;;  global 42 
    (VTF-push vtf :proto)                  ;;  global 43 
    (VTF-push vtf :typeof)                 ;;  global 44
    (VTF-push vtf :math-cos)               ;;  math  45
    (VTF-push vtf :math-sin)               ;;  math 46 
    (VTF-push vtf :math-tan)               ;;  math 47 
    (VTF-push vtf :math-acos)              ;;  math 48 
    (VTF-push vtf :math-asin)              ;;  math 49
    
    (VTF-push vtf :math-atan)              ;;  math 50 
    (VTF-push vtf :math-cosh)              ;;  math 51 
    (VTF-push vtf :math-sinh)              ;;  math 52
    (VTF-push vtf :math-tanh)              ;;  math 53
    (VTF-push vtf :math-log)               ;;  math 54
    (VTF-push vtf :math-exp)               ;;  math 55
    (VTF-push vtf :math-log10)             ;;  math 56
    (VTF-push vtf :math-pow)               ;;  math 57
    (VTF-push vtf :math-sqrt)              ;;  math 58
    (VTF-push vtf :math-ceil)              ;;  math 59
    
    (VTF-push vtf :math-floor)             ;;  math 60 
    (VTF-push vtf :string-find)            ;;  string 61 
    (VTF-push vtf :string-replace)         ;;  string 62 
    (VTF-push vtf :apply)                  ;;  global 63 
    (VTF-push vtf :vector-slice)           ;;  vector 64 
    (VTF-push vtf :set-car!)               ;;  global 65 
    (VTF-push vtf :set-cdr!)               ;;  global 66 
    (VTF-push vtf :sys-cmd)                ;;  sys 67
    (VTF-push vtf :<<)                     ;;  global 68
    (VTF-push vtf :>>)                     ;;  global 69
    
    (VTF-push vtf :>>>)                     ;;  global 70
    (VTF-push vtf :&)                       ;;  global 71
    (VTF-push vtf :|)                       ;;  global 72
    (VTF-push vtf :file-abs-path)           ;;  global 73
    (VTF-push vtf :float->int64t)           ;;  float  74 
    (VTF-push vtf :table-length)            ;;  table  75
    (VTF-push vtf :string-char-code-at)     ;;  string 76
    (VTF-push vtf :string-from-char-code)   ;;  string 77
    vt ;; return vt
    ))

;; several GLOBAL variables

(def GLOBAL-VT (VT-init))
(def GLOBAL-MODULE GLOBAL-VT[0]) ;; def global module, ~which is not initialized yet~
(def GLOBAL-LOADED-MODULES #[])            ;; save the abs path of loaded file
(def GLOBAL-CONSTANT-TABLE-FOR-COMPILATION {})   ;; save constant
(def CONSTANT-TABLE-INSTRUCTIONS (Make-Instructions)) ;; constant table instructions

;; variable table push variable table frame
(def VT-push-frame 
  (fn [vt vtf]
    (vector:push! vt vtf)))

;; variable table push empty frame
(def VT-add-new-empty-frame
  (fn [vt]
    (vector:push! vt (Make-Variable-Table-Frame))))
;; if not found, return ()
(def VT-find 
  (fn [vt var-name module]
    ;; check local
    ;; if find return offset, otherwise return ()
    (def check-local
      (fn [vt i]
        (if (= i 0)
          () ;; didn't find
          ;; check current frame
          (if (vt[i] var-name)
            #(i (vt[i] var-name)) ;; find
            (check-local vt (- i 1)) ;; continue
            ))))
    ;; check module
    (let [a (check-local vt (- (vector:length vt) 1))]
      (if a
        a ;; find in local
        (if (module var-name) 
          #(0 (module var-name)) ;; in module
          (if (GLOBAL-MODULE var-name)  
            #(0 (GLOBAL-MODULE var-name)) ;; in global module
            () ;; not found
            ))))))

(def Make-Lambda-for-Compilation
  (fn []
    {:param-num 0
     :variadic-place 0
     :start-pc 0
     :variable-table ()
     :is-tail-call 0}
    ))

;; Macro data structure
(def Make-Macro
  (fn [macro-name clauses vt]
    {:macro-name macro-name
     :clauses clauses
     :vt vt}))



;; begin to define compiler 
(def compiler ())
(def compiler-begin 
  (fn [insts 
       l 
       vt 
       parent-func-name 
       function-for-compilation 
       eval-flag 
       env 
       mt 
       module]
    0))
;(def compiler ())


;; quote list
;; (quote (1 2)) => (cons 1 (cons 2 ()))
(def quote-list
  (fn [l]
    (if (null? l)
      ()
      (let [v (car l)]
        (if (pair? v)
          (cons 'cons 
                (cons (quote-list v)
                      (cons (quote-list (cdr l))
                            ())))
          (if (and (string? v)
                   (eq? v "."))
            (cons 'quote 
                  (cons (car (cdr l))
                        ()))
            (cons 'cons
                  (cons (cons 'quote 
                              (cons v ()))
                        (cons (quote-list (cdr l))
                              ())))))))))

(def quasiquote-list 
  (fn [l]
    (if (null? l)
      ()
      (let [v (car l)]
        (cons (pair? v)
              ;=>
              (cond (and (string? (car v))
                         (eq? (car v) 'unquote))
                    ;=>
                    (cons 'cons
                          (cons (cadr v)
                                (cons (quasiquote-list (cdr l))
                                      ())))
                    (and (string? (car v))
                         (eq? (car v) 'unquote-splice))
                    ;=>
                    (cons 'append
                          (cons (cadr v)
                                (cons (quasiquote-list (cdr l)
                                                       ()))))
                    :else
                    ;=>
                    (cons 'cons
                          (cons (quasiquote-list v)
                                (cons (quasiquote-list (cdr l)
                                                       ()))))
                    )
              
              (and (string? v)
                   (eq? v "."))
              ;=>
              (cons 'quote 
                    (cons (cadr l)
                          ()))
              
              :else
              ;=>
              (cons 'cons
                    (cons (cons 'quote
                                (cons v ()))
                          (cons (quasiquote-list (cdr l))
                                ()))))))))

;; compile integer
(def compile-integer 
  (fn [insts l]
    (if (and (>= l 0)
                  (< l 250))
           ;; load from constant table directly
           (begin (Insts-push insts opcode:CONST_LOAD)
                  (Insts-push insts l)
                  0) ;; return 0
           (begin
            ;; construct integer 
            (Insts-push insts opcode:CONST_INTEGER)
            (Insts-push insts (>>> (& 0xFFFF000000000000 l)
                                  48))
            (Insts-push insts (>>> (& 0x0000FFFF00000000 l)
                                  32))
            (Insts-push insts (>>> (& 0x00000000FFFF0000 l)
                                  16))
            (Insts-push insts (>>> (& 0x000000000000FFFF l)
                                   0))
            0) ;; return 0
           )))
(def compile-float
  (fn [insts v]
    (def l (float->int64 v))
    (Insts-push insts opcode:CONST_INTEGER)
    (Insts-push insts (>>> (& 0xFFFF000000000000 l)
                                  48))
    (Insts-push insts (>>> (& 0x0000FFFF00000000 l)
                                  32))
    (Insts-push insts (>>> (& 0x00000000FFFF0000 l)
                                  16))
    (Insts-push insts (>>> (& 0x000000000000FFFF l)
                           0))
    0)) ;; return 0

(def compile-string
  (fn [insts input-str]
    (def input-str-length (string:length input-str))
                                        ;format string
                                        ;eg ""Hello World"" -> Hello World
    (print input-str-length)
    (def format-string 
      (fn [i output-str]
        (if (= i (- input-str-length 1))
          output-str
          (format-string (+ i 1)
                         (string-append output-str
                                        (if (string=? input-str[i] "\\")
                                          (cond (string=? input-str[(+ i 1)] 'a)
                                                "\a"
                                                (string=? input-str[(+ i 1)] 't)
                                                "\t"
                                                (string=? input-str[(+ i 1)] 'n)
                                                "\n"
                                                (string=? input-str[(+ i 1)] "\\")
                                                "\\"
                                                (string=? input-str[(+ i 1)] "\"")
                                                "\""
                                                :else 
                                                (begin (error "Invalid String Slash")
                                                       (print input-str)
                                                       (print "\n")
                                                       ""))
                                          input-str[i]))))))
    (def s (format-string 1 "")) ;; format string
    (def s-length (string:length s))
    (print input-str)
    (print s)
    (print s-length)
    (def compile-formatted-string 
      (fn [i]
        (if (= (+ i 1)
               s-length)
          (Insts-push CONSTANT-TABLE-INSTRUCTIONS
                      (& (<< (string:char-code-at s i) 8)
                         0xFF00))
          (if (= i
                 s-length)
            (Insts-push CONSTANT-TABLE-INSTRUCTIONS
                        0x0000)
            (begin (Insts-push CONSTANT-TABLE-INSTRUCTIONS
                               (| (<< (string:char-code-at s i) 8)
                                  (string:char-code-at s (+ i 1))))
                   (compile-formatted-string (+ i 2)))))))
    
    ;; check s in constant table
    (if (GLOBAL-CONSTANT-TABLE-FOR-COMPILATION s) 
      ;; already existed
      (begin (Insts-push insts opcode:CONST_LOAD) ;; load from table
             (Insts-push insts (GLOBAL-CONSTANT-TABLE-FOR-COMPILATION s)) ;; push offset
             0) ;; return 0
      ;; doesn't exist
      (begin (Insts-push insts opcode:CONST_LOAD)  ;; load from table
             (Insts-push insts (table:length GLOBAL-CONSTANT-TABLE-FOR-COMPILATION)) ;; save offset
             (GLOBAL-CONSTANT-TABLE-FOR-COMPILATION s (table:length GLOBAL-CONSTANT-TABLE-FOR-COMPILATION))  ;; save to constant table
             ;; constant table instructions
             (Insts-push CONSTANT-TABLE-INSTRUCTIONS opcode:CONST_STRING)
             (Insts-push CONSTANT-TABLE-INSTRUCTIONS s-length) 

             ;; compile formatted string
             (compile-formatted-string 0)
             0))))
(print "\n Implementing Compiler\n")

;; compile doesn't support macro yet
(set! compiler 
      (fn [insts 
           l
           vt
           tail-call-flag
           parent-func-name
           function-for-compilation
           env
           mt
           module]
        ;; compile quote
        (def compile-quote 
          (fn [] 
            (let [v (cadr l)]
              (cond (or (null? v)    ;; () 12 12.3 just compile them
                        (integer? v)
                        (float? v))
                    (compiler insts
                              v
                              vt
                              tail-call-flag
                              parent-func-name
                              function-for-compilation
                              env
                              mt
                              module)
                    (list? v)        ;; list
                    (compiler insts
                              (quote-list v)
                              vt 
                              tail-call-flag 
                              parent-func-name 
                              function-for-compilation 
                              env 
                              mt 
                              module)
                    
                    (and (string? v)  ;; atom symbol
                         (not (string=? v[0] "'")))
                    (let [that-symbol (string-append "\"" (string-append v "\""))]
                      (compiler insts 
                                that-symbol 
                                vt 
                                tail-call-flag 
                                parent-func-name 
                                function-for-compilation 
                                env 
                                mt 
                                module))
                    :else 
                    (compiler insts 
                              v 
                              vt 
                              tail-call-flag 
                              parent-func-name 
                              env 
                              mt 
                              module)))))
        (def compile-quasiquote ;; compile quasiquote
          (fn []
            (let [v (cadr l)]
              (cond (or (null? v)    ;; () 12 12.3 just compile them
                        (integer? v)
                        (float? v))
                    (compiler insts
                              v
                              vt
                              tail-call-flag
                              parent-func-name
                              function-for-compilation
                              env
                              mt
                              module)
                    (list? v)   ;; list
                    (compiler insts
                              (quasiquote-list v)
                              vt 
                              tail-call-flag 
                              parent-func-name 
                              function-for-compilation 
                              env 
                              mt
                              module)
                    (and (string? v)  ;; atom symbol
                         (not (string=? v[0] "'")))
                    (let [that-symbol (string-append "\"" (string-append v "\""))]
                      (compiler insts 
                                that-symbol 
                                vt 
                                tail-call-flag 
                                parent-func-name 
                                function-for-compilation 
                                env 
                                mt 
                                module))
                    :else 
                    (compiler insts 
                              v 
                              vt 
                              tail-call-flag 
                              parent-func-name 
                              env 
                              mt 
                              module)))))
        (def compile-if  ;;; compile if (if 1 2 3)
          (fn [] 
            (let [test (cadr l)
                  conseq (caddr l)
                  alter (if (null? (cdddr l)) () (cadddr l))]
              ;; compile test
              (compiler insts 
                        test 
                        vt 
                        () 
                        parent-func-name 
                        function-for-compilation 
                        env 
                        mt 
                        module)
              ;; push test, but now we don't know jump steps
              (Insts-push insts (<< opcode:TEST 12)) ;; jump over consequence
              (let [index1 (vector:length insts:array)]
                (Insts-push insts 0x0000) ;; jump steps
                ;; compile conseq
                (compiler-begin insts 
                                (cons conseq ())
                                vt 
                                parent-func-name 
                                function-for-compilation 
                                () ;; cannot eval
                                env 
                                mt 
                                module)
                (let [index2 (vector:length insts:array)]
                  (Insts-push insts (<< opcode:JMP 12))  ;; jmp 
                  (Insts-push insts 0x0000)              ;; jump over alternative
                  (Insts-push insts 0x0000) 
                  (let [jump-steps (+ (- index2 index1)
                                      4)]
                    (Insts-set! insts index1 jump-steps) ;; set jump steps
                    ;; compile alter
                    (compiler-begin insts 
                                    (cons alter ())
                                    vt 
                                    parent-func-name 
                                    function-for-compilation 
                                    ()  ;; cannot eval
                                    env 
                                    mt 
                                    module)
                    (let [index3 (vector:length insts:array)
                          jump-steps (- index3 index2)]
                      (Insts-set! insts (+ index2 1) (>> (& 0xffff0000 jump-steps)
                                                         16))
                      (Insts-set! insts (+ index2 2) (& 0x0000FFFF jump-steps))))
                  0))))) ;; return 0
        (def compile-let  ;; not finished
          (fn [] 
            (let [chunk (cadr l)]
              ())))
        (def compile-make-fn ;; make fn 
          (fn []
            (let [params (cadr l)
                  variadic-place -1 
                  vt_ (vector:slice vt 0 (vector:length vt)) ;; copy vt
                  mt_ (vector:slice mt 0 (vector:length mt)) ;; copy mt
                  temp-top-frame (Make-Variable-Table-Frame)      ;; temp-top-frame
                  ]
              (def get-counter-and-set!-variadic-place 
                (fn [params counter]
                  (cond (null? params) ;; done
                            counter 
                        (not (string? (car params))) ;; invalid param type
                            (begin (error "Invalid Function Parameter Type\n")
                                   (print (car params))
                                   (print "\n")
                                   0)
                        (eq? (car params) ".") ;; variadic place
                            (begin (set! variadic-place counter) ;; set variadic-place
                                   (VTF-push temp-top-frame (cadr params))
                                   (+ counter 1))
                        :else
                            (begin (VTF-push temp-top-frame (cadr params))
                                   (get-counter-and-set!-variadic-place (cdr params)
                                                                        (+ counter 1)))
                        )))
              (vector:push! vt_ temp-top-frame)         ;; add a new frame
              (vector:push! mt_ {})    ;; add a new frame
              (let [counter (get-counter-and-set!-variadic-place params 
                                                                 0) ;; get param num
                    index1 (+ 1 (vector:length insts:array))
                    start-pc (+ 2 index1)
                    function-for-compilation_ {:start-pc start-pc
                                               :param-num counter 
                                               :variadic-place variadic-place 
                                               :vt vt_ 
                                               :is-tail-call 0}
                    ]
                (Insts-push insts 
                            (| (<< opcode:MAKELAMBDA 12)
                               (| (<< counter 6)
                                  (| (if (= variadic-place -1) 0 (<< variadic-place 1))
                                     (if (= variadic-place -1) 0 1)))))
                (Insts-push insts 0x0000) ;; steps that needed to jump over lambda
                (Insts-push insts 0x0000) ;; used to save frame length
                (compiler-begin insts ;; compile body
                                (cddr l)
                                vt_ 
                                parent-func-name 
                                function-for-compilation_ 
                                () 
                                env 
                                mt_ 
                                module)
                (Insts-push insts (<< opcode:RETURN 12)) ;; push RETURN opcode
                (let [index2 (vector:length insts:array)
                      ]
                  (Insts-set! insts index1 (+ (- index2 index1) 1)) ;; set jump steps
                  (Insts-set! insts (+ index1 1)  ;; save frame length
                              (if (= variadic-place -1)
                                (table:length temp-top-frame)
                                64))
                  0)))))  
        (def compile-call-fn 
          (fn [] 
            (def compile-params  ;; compile params and return params-num
              (fn [params num]
                (if (null? params)
                  num
                  (begin (compiler insts  ;; compile param
                                   (car params)
                                   vt 
                                   ()
                                   parent-func-name 
                                   function-for-compilation 
                                   env 
                                   mt 
                                   module)
                         (Insts-push insts (<< opcode:PUSH_ARG 12))
                         (compile-params (cdr params) (+ num 1))))))
            ;; TODO check macro
            (if tail-call-flag 
              ;; tail call
              (begin   ;; tail call, so no new frame
               ())     ;; TODO : support tail call
              
              ;; not tail call
              ;;
              (begin (compiler insts  ;; compile function first
                               (car l)
                               vt 
                               () 
                               parent-func-name 
                               function-for-compilation 
                               env 
                               mt 
                               module)
                     (Insts-push insts (<< opcode:NEWFRAME 12)) ;; create new frame
                     (Insts-push insts (| (<< opcode:CALL 12)
                                          (& 0x0fff (compile-params (cdr l) ;; compile params
                                                                    0))))
                     0))))

        (cond 
         (null? l) ;; type of l is  null
         (begin (Insts-push insts opcode:CONST_NULL) 
                0) ;; return 0
         (integer? l) ;; type of l is integer
         (compile-integer insts l)
         
         (float? l) ;; type of l is float
         (compile-float insts l)

         (string? l) ;; type of l is string
         (if (and (> (string:length l) 0) (string=? l[0] "\""))
           ;; compile string
           (compile-string insts l) 
           ;; get variable
           (let [v (VT-find vt 
                            l
                            module)]
             (if v
               ;; found
               (begin (Insts-push insts (| (<< opcode:GET 12) ;; frame index
                                           v[0]))
                      (Insts-push insts v[1])                 ;; value index
                      (if (or (eq? l 'break)                  ;; meet break, continue : return from fn
                              (eq? l 'continue))
                        (begin (Insts-push insts (<< opcode:RETURN 12))
                               0)
                        0))
               ;; not found
               (begin (error (string:append "Undefined variable " l))
                      0))))
         
         (list? l)  ;; type of l is list 
         (let [tag (car l)]
           (cond (eq? tag 'quote)  ;; (quote (1 2 3)) (quote abc)
                     (compile-quote)   ;; compile quote
                 (eq? tag 'quasiquote) ;; quasiquote
                     (compile-quasiquote) ;; compile quasiquote
                 (eq? tag 'def)
                     ()
                 (eq? tag 'set!)
                     ()
                 (eq? tag 'load)
                     ()
                 (eq? tag 'require)
                     ()
                 (eq? tag 'if)
                     (compile-if)
                 (eq? tag 'begin)
                     (compiler-begin insts 
                                     (cdr l)
                                     vt 
                                     parent-func-name 
                                     function-for-compilation 
                                     ()  ;; cannot eval
                                     env 
                                     mt)
                 (eq? tag 'let)
                     (compile-let)
                 (or (eq? tag 'lambda)
                     (eq? tag 'fn))
                     (compile-make-fn)
                 (eq? tag 'defmacro)
                     ()
                 :else ;;; call fn
                     (compile-call-fn)
                 ))  

         :else
             (begin (error "Invalid Expression")
                    (print l)
                    (print "\n"))
             )))

;; test compiler
;(def insts (Make-Instructions))
;(compiler insts 
;          "Table"
;          GLOBAL-VT
;          0
;          0
;          0
;          0
;          0
;          GLOBAL-MODULE)
;(print "\n Constant: \n")
;(Insts-print CONSTANT-TABLE-INSTRUCTIONS)

;(print "\n\n Instructions: \n")
;(Insts-print insts)
;(print "Hi")
