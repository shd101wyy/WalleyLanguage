;; walley language compiler
;; by Yiyi Wang
;; all rights reserved


;; def opcodes
(def opcode 
  {:SET 0x0 
   :GET 0x1
   :CONST 0x2
   
   :CONST_INTEGER 0x2100
   :CONST_FLOAT 0x2200
   :CONST_STRING 0x2300
   :CONST_NULL 0x2400
   :CONST_LOAD 0x2500

   :MAKELAMBDA 0x3
   :RETURN 0x4
   :NEWFRAME 0x5
   :PUSH_ARG 0x6
   :CALL 0x7
   :JMP 0x8
   :TEST 0x9
   :SET_TOP 0xA
   :TAIL_CALL_PUSH 0xB
   :OBJECT_GET_SELF 0xC
   :OBJECT_GET_PARENT 0xD
   :TABLE_GET 0xE
   })

;; generate instructions data structions
(def Make-Instructions 
  (fn []
    {:array #[]
     :start-pc 0
     }))

;; insts push instructions
(def Insts-push 
  (fn [insts v]
    (vector:push! insts:array v)))
;; insts to string
(def Insts->string 
  (fn [insts]
    (def insts-array insts:array)
    (def insts-length (vector:length insts-array))
    (def helper 
      (fn [count output]
        (if (= count insts-length)
          output
          (helper (+ count 1)
                  (string-append output 
                                 (int:->string insts-array[count]
                                               "%04x "))))))
    (helper 0 "")))
;; print insts
(def Insts-print 
  (fn [insts]
    (print (Insts->string insts))))

;; test instructions
;(def x (Make-Instructions))
;(Insts-push x 12)
;(Insts-print x)

;; def module
;; module saves variables names and their offsets
;; under global scope
(def Make-Module 
  (fn []
    {}))

;; make variable table frame
(def Make-Variable-Table-Frame 
  (fn []
    {:var-names {}
     :length     0}))
;; push variable name to variable table frame
(def VTF-push 
  (fn [vtf v]
    (set! ((vtf :var-names) v) vtf:length)
    (set! vtf:length (+ vtf:length 1))))
;; make variable table
;; vector that store the variable table frame
(def Make-Variable-Table
  (fn []
    #[]))
;; initialize a variable table
(def VT-init
  (fn []
    (def vt #[])  ;;; def a variable table
    (def vtf (Make-Variable-Table-Frame))  ;;; def a variable table frame 
    (vector:push! vt vtf) ;;; add this variable table frame to variable table
   
    ;; add predefined variable name
    ;; set frame0                        ;;    module
    (VTF-push vtf :cons)                   ;;  global 0
    (VTF-push vtf :car)                    ;;  global 1
    (VTF-push vtf :cdr)                    ;;  global 2
    (VTF-push vtf :+)                      ;;  global 3
    (VTF-push vtf :-)                      ;;  global 4
    (VTF-push vtf :*)                      ;;  global 5
    (VTF-push vtf :/)                      ;;  global 6
    (VTF-push vtf :Vector!)                ;;  global 7 
    (VTF-push vtf :Vector)                 ;;  global 8
    (VTF-push vtf :vector-length)          ;;  vector 9 
    
    (VTF-push vtf :vector-push!)           ;;  vector 10 
    (VTF-push vtf :vector-pop!)            ;;  vector 11 
    (VTF-push vtf :=)                      ;;  global 12 
    (VTF-push vtf :<)                      ;;  global 13
    (VTF-push vtf :<=)                     ;;  global 14 
    (VTF-push vtf :eq?)                    ;;  global 15
    (VTF-push vtf :eval)                   ;;  global 16 
    (VTF-push vtf :exit)                   ;;  global 17
    (VTF-push vtf :>)                      ;;  global 18
    (VTF-push vtf :>=)                     ;;  global 19
    
    (VTF-push vtf :parse)                  ;;  global 20
    (VTF-push vtf :random)                 ;;  global 21 
    (VTF-push vtf :strcmp)                 ;;  global 22 
    (VTF-push vtf :string-slice)           ;;  string 23 
    (VTF-push vtf :string-length)          ;;  string 24 
    (VTF-push vtf :string-append)          ;;  string 25 
    (VTF-push vtf :Table)                  ;;  global 26 
    (VTF-push vtf :table-keys)             ;;  table 27 
    (VTF-push vtf :table-delete)           ;;  table 28 
    (VTF-push vtf :file-read)              ;;  file 29 
    
    (VTF-push vtf :file-write)             ;;  file 30 
    (VTF-push vtf :sys-argv)               ;;  sys  31
    (VTF-push vtf :int->string)            ;;  int  32 
    (VTF-push vtf :float->string)          ;;  float 33 
    (VTF-push vtf :input)                  ;;  global 34
    (VTF-push vtf :print)                  ;;  global 35 
    (VTF-push vtf :string->int)            ;;  string 36 
    (VTF-push vtf :string->float)          ;;  string 37 
    (VTF-push vtf :ratio?)                 ;;  global 38 
    (VTF-push vtf :ratio-numer)            ;;  ratio 39 
    
    (VTF-push vtf :ratio-denom)            ;;  ratio 40 
    (VTF-push vtf :gensym)                 ;;  global 41 
    (VTF-push vtf :add-proto)              ;;  global 42 
    (VTF-push vtf :proto)                  ;;  global 43 
    (VTF-push vtf :typeof)                 ;;  global 44
    (VTF-push vtf :math-cos)               ;;  math  45
    (VTF-push vtf :math-sin)               ;;  math 46 
    (VTF-push vtf :math-tan)               ;;  math 47 
    (VTF-push vtf :math-acos)              ;;  math 48 
    (VTF-push vtf :math-asin)              ;;  math 49
    
    (VTF-push vtf :math-atan)              ;;  math 50 
    (VTF-push vtf :math-cosh)              ;;  math 51 
    (VTF-push vtf :math-sinh)              ;;  math 52
    (VTF-push vtf :math-tanh)              ;;  math 53
    (VTF-push vtf :math-log)               ;;  math 54
    (VTF-push vtf :math-exp)               ;;  math 55
    (VTF-push vtf :math-log10)             ;;  math 56
    (VTF-push vtf :math-pow)               ;;  math 57
    (VTF-push vtf :math-sqrt)              ;;  math 58
    (VTF-push vtf :math-ceil)              ;;  math 59
    
    (VTF-push vtf :math-floor)             ;;  math 60 
    (VTF-push vtf :string-find)            ;;  string 61 
    (VTF-push vtf :string-replace)         ;;  string 62 
    (VTF-push vtf :apply)                  ;;  global 63 
    (VTF-push vtf :vector-slice)           ;;  vector 64 
    (VTF-push vtf :set-car!)               ;;  global 65 
    (VTF-push vtf :set-cdr!)               ;;  global 66 
    (VTF-push vtf :sys-cmd)                ;;  sys 67
    (VTF-push vtf :<<)                     ;;  global 68
    (VTF-push vtf :>>)                     ;;  global 69
    
    (VTF-push vtf :>>>)                     ;;  global 70
    (VTF-push vtf :&)                       ;;  global 71
    (VTF-push vtf :|)                       ;;  global 72
    (VTF-push vtf :file-abs-path)           ;;  global 73
    (VTF-push vtf :float->int64t)           ;;  float  74 
    vt ;; return vt
    ))

;; several GLOBAL variables

(def GLOBAL-VT (VT-init))
(def GLOBAL-MODULE GLOBAL-VT[0]:var-names) ;; def global module, ~which is not initialized yet~
(def GLOBAL-LOADED-MODULES #[])            ;; save the abs path of loaded file


;; variable table push variable table frame
(def VT-push-frame 
  (fn [vt vtf]
    (vector:push! vt vtf)))

;; variable table push empty frame
(def VT-add-new-empty-frame
  (fn [vt]
    (vector:push! vt (Make-Variable-Table-Frame))))

(def VT-find 
  (fn [vt var-name module]
    ;; check local
    ;; if find return offset, otherwise return ()
    (def check-local
      (fn [vt i]
        (if (= i 0)
          () ;; didn't find
          ;; check current frame
          (if (vt[i]:var-names var-name)
            #(i (vt[i]:var-names var-name)) ;; find
            (check-local vt (- i 1)) ;; continue
            ))))
    ;; check module
    (let [a (check-local vt (- (vector:length vt) 1))]
      (if a
        a ;; find in local
        (if (module var-name) 
          #(0 (module var-name)) ;; in module
          (if (GLOBAL-MODULE var-name)  
            #(0 (GLOBAL-MODULE var-name)) ;; in global module
            #(-1, -1)))))))

(def Make-Lambda-for-Compilation
  (fn []
    {:param-num 0
     :variadic-place 0
     :start-pc 0
     :variable-table ()
     :is-tail-call 0}
    ))

;; Macro data structure
(def Make-Macro
  (fn [macro-name clauses vt]
    {:macro-name macro-name
     :clauses clauses
     :vt vt}))



;; begin to define compiler 
(def compiler-begin ())
(def compiler ())

;; quote list
;; (quote (1 2)) => (cons 1 (cons 2 ()))
(def quote-list
  (fn [l]
    (if (null? l)
      ()
      (let [v (car l)]
        (if (pair? v)
          (cons 'cons 
                (cons (quote-list v)
                      (cons (quote-list (cdr l))
                            ())))
          (if (and (string? v)
                   (eq? v "."))
            (cons 'quote 
                  (cons (car (cdr l))
                        ()))
            (cons 'cons
                  (cons (cons 'quote 
                              (cons v ()))
                        (cons (quote-list (cdr l))
                              ())))))))))

(def quasiquote-list 
  (fn [l]
    (if (null? l)
      ()
      (let [v (car l)]
        (cons (pair? v)
              ;=>
              (cond (and (string? (car v))
                         (eq? (car v) 'unquote))
                    ;=>
                    (cons 'cons
                          (cons (cadr v)
                                (cons (quasiquote-list (cdr l))
                                      ())))
                    (and (string? (car v))
                         (eq? (car v) 'unquote-splice))
                    ;=>
                    (cons 'append
                          (cons (cadr v)
                                (cons (quasiquote-list (cdr l)
                                                       ()))))
                    :else
                    ;=>
                    (cons 'cons
                          (cons (quasiquote-list v)
                                (cons (quasiquote-list (cdr l)
                                                       ()))))
                    )
              
              (and (string? v)
                   (eq? v "."))
              ;=>
              (cons 'quote 
                    (cons (cadr l)
                          ()))
              
              :else
              ;=>
              (cons 'cons
                    (cons (cons 'quote
                                (cons v ()))
                          (cons (quasiquote-list (cdr l))
                                ()))))))))

;; compile integer
(def compile-integer 
  (fn [insts l]
    (if (and (>= l 0)
                  (< l 250))
           ;; load from constant table directly
           (begin (Insts-push insts opcode:CONST_LOAD)
                  (Insts-push insts l)
                  0) ;; return 0
           (begin
            ;; construct integer 
            (Insts-push insts opcode:CONST_INTEGER)
            (Insts-push insts (>>> (& 0xFFFF000000000000 l)
                                  48))
            (Insts-push insts (>>> (& 0x0000FFFF00000000 l)
                                  32))
            (Insts-push insts (>>> (& 0x00000000FFFF0000 l)
                                  16))
            (Insts-push insts (>>> (& 0x000000000000FFFF l)
                                   0))
            0) ;; return 0
           )))
(def compile-float
  (fn [insts v]
    (def l (float->int64 v))
    (Insts-push insts opcode:CONST_INTEGER)
    (Insts-push insts (>>> (& 0xFFFF000000000000 l)
                                  48))
    (Insts-push insts (>>> (& 0x0000FFFF00000000 l)
                                  32))
    (Insts-push insts (>>> (& 0x00000000FFFF0000 l)
                                  16))
    (Insts-push insts (>>> (& 0x000000000000FFFF l)
                           0))
    0)) ;; return 0

;; compile doesn't support macro yet
(set! compiler 
      (fn [insts 
           l
           vt
           tail-call-flag
           parent-func-name
           function-for-compilation
           env
           mt
           module]
        (cond 
         (null? l) ;; type of l is  null
         (begin (Insts-push insts opcode:CONST_NULL) 
                0) ;; return 0
         (integer? l) ;; type of l is integer
         (compile-integer insts l)
         
         (float? l) ;; type of l is float
         (compile-float insts l)

         (string? l) ;; type of l is string
         ()
         
         (list? l)  ;; type of l is list
         ()

         :else
         (begin (error "Invalid Expression")
                (print l)
                (print "\n"))
         )
        ))

;; test compiler
(def insts (Make-Instructions))
(compiler insts 
          -12.4
          ()
          0
          0
          0
          0
          0
          0)
(Insts-print insts)
